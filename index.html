<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
  <title>Place Value: Resource Edition</title>
  <link href="https://fonts.googleapis.com/css2?family=Lexend:wght@400;700;900&display=swap" rel="stylesheet"/>
  <style>
    *{margin:0;padding:0;box-sizing:border-box}
    :root{
      --bg:#f3f4f6; 
      --ink:#111827;
      --tray:#1f2937; 
      --accent:#3b82f6;
      --block-size: 40px; 
      --block-height: 60px;
      --whole-bg: #e8eef4;
      --whole-text: #334155;
      --whole-border: #cbd5e1;
      --decimal-bg: #fef3ee;
      --decimal-text: #9a3412;
      --decimal-border: #fed7aa;
    }

    body{
      font-family:'Lexend',sans-serif;
      background:var(--bg);
      color:var(--ink);
      height:100vh;
      overflow:hidden;
      touch-action:none;
      user-select: none;
      overscroll-behavior: none;
    }

    #app{position:relative;height:calc(100% - 50px);width:100%; display:flex; flex-direction:column;}

    #dashboard {
      height: 50px;
      background: white;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 15px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      z-index: 50;
    }

    .dash-group { display: flex; align-items: center; gap: 12px; }

    #totalDisplay {
      font-size: 20px;
      font-weight: 900;
      color: #374151;
      background: #f3f4f6;
      padding: 4px 16px;
      border-radius: 25px;
      min-width: 80px;
      text-align: center;
      border: 2px solid #e5e7eb;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .btn {
      border: none;
      background: #374151;
      color: white;
      padding: 6px 12px;
      border-radius: 6px;
      font-weight: 700;
      font-family: inherit;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 6px;
      transition: transform 0.1s, background 0.2s;
      font-size: 13px;
    }
    .btn:hover { background: #1f2937; transform: translateY(-1px); }
    .btn:active { transform: translateY(1px); }
    .btn-icon { font-size: 18px; }
    .btn-primary { background: var(--accent); }
    .btn-primary:hover { background: #2563eb; }
    .btn-danger { background: #ef4444; }
    .btn-danger:hover { background: #dc2626; }

    #numberLinePanel {
      background: white;
      border-bottom: 1px solid #e5e7eb;
      padding: 8px 20px 5px;
      z-index: 45;
    }
    
    .zoom-bar-container { margin-bottom: 8px; }
    
    .zoom-bar {
      position: relative;
      height: 8px;
      background: linear-gradient(to right, #3498db, #9b59b6, #e74c3c);
      border-radius: 4px;
      margin-bottom: 5px;
    }
    
    .zoom-indicator {
      position: absolute;
      top: -4px;
      width: 4px;
      height: 16px;
      background: #2c3e50;
      border-radius: 2px;
      transition: left 0.3s ease;
      box-shadow: 0 2px 4px rgba(0,0,0,0.3);
    }
    
    .zoom-labels {
      display: flex;
      justify-content: space-between;
      font-size: 0.65rem;
      color: #9ca3af;
    }
    
    .number-line-container {
      position: relative;
      height: 65px; 
      cursor: ns-resize;
      overflow: visible; 
      margin: 5px 50px 0 50px;
    }
    
    .number-line {
      width: 100%;
      height: 40px;
      position: relative;
      background: linear-gradient(to bottom, transparent 46%, #2c3e50 46%, #2c3e50 54%, transparent 54%);
    }
    
    .tick {
      position: absolute;
      top: 25%;
      width: 2px;
      height: 50%;
      background: #d1d5db;
      transform: translateX(-50%);
    }
    
    .tick.major {
      top: 15%;
      width: 2px;
      height: 70%;
      background: #6b7280;
    }
    
    .tick-label {
      position: absolute;
      top: 42px; 
      transform: translateX(-50%);
      font-weight: 600;
      font-size: 0.7rem;
      color: #6b7280;
      white-space: nowrap;
    }
    
    .value-dot {
      position: absolute;
      width: 16px;
      height: 16px;
      background: #e74c3c;
      border: 2px solid white;
      border-radius: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      z-index: 10;
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
    }
    
    .dot-label {
      position: absolute;
      top: -24px;
      left: 50%;
      transform: translateX(-50%);
      background: #e74c3c;
      color: white;
      padding: 2px 6px;
      border-radius: 4px;
      font-weight: 700;
      font-size: 0.7rem;
      white-space: nowrap;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }
    
    .dot-label::after {
      content: '';
      position: absolute;
      bottom: -4px;
      left: 50%;
      transform: translateX(-50%);
      border-left: 4px solid transparent;
      border-right: 4px solid transparent;
      border-top: 4px solid #e74c3c;
    }
    
    .zoom-hint {
      display: none;
    }

    #workPane{
      flex: 1;
      position:relative;
      background:radial-gradient(circle at center, #ffffff 0%, #f3f4f6 100%);
      overflow:hidden;
    }
    
    #snapLine{
      position:absolute;
      top:50%;
      left:0; right:0;
      height:2px;
      background:rgba(0,0,0,0.04);
      pointer-events:none;
      z-index:5;
    }
    #snapLine .decimal-point {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: 14px;
      height: 14px;
      background: #475569;
      border-radius: 50%;
      margin-top: 35px;
    }

    #bottomDock{
      height: 22vh;
      min-height: 140px;
      background: var(--tray);
      display: flex; flex-direction: column;
      z-index: 60;
      box-shadow: 0 -4px 20px rgba(0,0,0,0.15);
    }

    #drawerTabs{
      display:flex;
      background:#374151;
      overflow-x:auto;
      padding: 0 10px;
      scrollbar-width: none;
    }
    #drawerTabs::-webkit-scrollbar { display: none; }

    .drawer-tab{
      padding:8px 14px;
      background:transparent; color: #9ca3af;
      border:none; cursor:pointer;
      font-weight:700; font-size:11px;
      white-space:nowrap; transition:all .2s;
      border-bottom: 3px solid transparent;
    }
    .drawer-tab.active{
      color: white; background: rgba(255,255,255,0.1);
      border-bottom: 3px solid var(--accent);
    }

    #baseTiles{
      flex:1;
      padding:10px 15px;
      overflow-x: auto; overflow-y: hidden;
      display:flex; align-items:center;
    }
    .base-row{ display:flex; gap:10px; margin: 0 auto; }

    .tile{
      height:var(--block-height);
      display:flex;
      cursor:grab;
      border-radius:12px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.08);
      background: var(--whole-bg);
      border: 2px solid var(--whole-border);
      overflow:hidden;
      transition: transform 0.1s, box-shadow 0.1s;
      touch-action: none; 
    }
    .tile:active{ cursor:grabbing; }
    .work-pane-tile{ position:absolute; transition: left 0.2s, top 0.2s; }

    .digit-block{
      width:var(--block-size); height:var(--block-height);
      display:flex; align-items:center; justify-content:center;
      font-weight:700; font-size:28px; line-height:1;
      color: var(--whole-text);
      flex-shrink: 0; 
    }
    .comma-block{ width:14px; align-items:flex-end; padding-bottom:10px; flex-shrink: 0; }
    .decimal-block{ width:14px; font-size:28px; font-weight:700; align-items:flex-end; padding-bottom:8px; flex-shrink: 0; }

    .tile.decimal-tile {
      background: var(--decimal-bg);
      border-color: var(--decimal-border);
    }
    .tile.decimal-tile .digit-block {
      color: var(--decimal-text);
    }
    
    /* THE GHOST - semi-transparent card following cursor */
    .drag-ghost {
      position: fixed;
      z-index: 10000;
      pointer-events: none;
      opacity: 0.7;
      box-shadow: 0 15px 40px rgba(0,0,0,0.3);
      cursor: grabbing;
      transform-origin: center center;
    }
    

    
    .plus-sign {
      position: absolute;
      font-size: 28px;
      font-weight: 700;
      color: #9ca3af;
      pointer-events: none;
      z-index: 200;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 30px;
      height: var(--block-height);
    }
  </style>
</head>
<body>

  <div id="dashboard">
    <div class="dash-group">
      <button class="btn btn-danger" id="resetBtn"><span class="btn-icon">ðŸ—‘</span> Clear</button>
      <div id="totalDisplay">
        <span id="sumText">0</span>
        <button class="btn btn-primary" id="speakBtn" style="padding:4px 8px; border-radius:20px; min-width:auto;" title="Read Aloud">ðŸ”Š</button>
      </div>
    </div>
    <div class="dash-group">
      <button class="btn" id="expandBtn"><span class="btn-icon">ðŸ’¥</span> Expand</button>
    </div>
  </div>

  <div id="app">
    <div id="numberLinePanel">
      <div class="zoom-bar-container">
        <div class="zoom-bar">
          <div class="zoom-indicator" id="zoomIndicator"></div>
        </div>
        <div class="zoom-labels">
          <span>0.001</span><span>0.01</span><span>0.1</span><span>1</span><span>10</span>
          <span>100</span><span>1K</span><span>10K</span><span>100K</span><span>1M</span>
        </div>
      </div>
      <div class="number-line-container" id="numberLineContainer">
        <div class="number-line" id="numberLine"></div>
      </div>
      <div class="zoom-hint">Ctrl+scroll or pinch to zoom</div>
    </div>

    <div id="workPane">
      <div id="snapLine"><div class="decimal-point"></div></div>
    </div>

    <div id="bottomDock">
      <div id="drawerTabs">
        <button class="drawer-tab" data-drawer="millions">Millions</button>
        <button class="drawer-tab" data-drawer="hundredThousands">H. Thousands</button>
        <button class="drawer-tab" data-drawer="tenThousands">T. Thousands</button>
        <button class="drawer-tab" data-drawer="thousands">Thousands</button>
        <button class="drawer-tab" data-drawer="hundreds">Hundreds</button>
        <button class="drawer-tab" data-drawer="tens">Tens</button>
        <button class="drawer-tab active" data-drawer="ones">Ones</button>
        <button class="drawer-tab" data-drawer="tenths">Tenths</button>
        <button class="drawer-tab" data-drawer="hundredths">Hundredths</button>
        <button class="drawer-tab" data-drawer="thousandths">Thousandths</button>
      </div>
      <div id="baseTiles">
        <div class="base-row" id="baseRow"></div>
      </div>
    </div>
  </div>

  <script>
    const BLOCK_SIZE = 40;
    const BLOCK_HEIGHT = 60;
    
    const PLACE_VALUES = {
      tenths: [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9],
      hundredths: [0.01, 0.02, 0.03, 0.04, 0.05, 0.06, 0.07, 0.08, 0.09],
      thousandths: [0.001, 0.002, 0.003, 0.004, 0.005, 0.006, 0.007, 0.008, 0.009],
      ones: [1, 2, 3, 4, 5, 6, 7, 8, 9],
      tens: [10, 20, 30, 40, 50, 60, 70, 80, 90],
      hundreds: [100, 200, 300, 400, 500, 600, 700, 800, 900],
      thousands: [1000, 2000, 3000, 4000, 5000, 6000, 7000, 8000, 9000],
      tenThousands: [10000, 20000, 30000, 40000, 50000, 60000, 70000, 80000, 90000],
      hundredThousands: [100000, 200000, 300000, 400000, 500000, 600000, 700000, 800000, 900000],
      millions: [1000000, 2000000, 3000000, 4000000, 5000000, 6000000, 7000000, 8000000, 9000000]
    };

    const ZOOM_LEVELS = [
      { name: 'Thousandths', step: 0.001, decimals: 4 },
      { name: 'Hundredths', step: 0.01, decimals: 3 },
      { name: 'Tenths', step: 0.1, decimals: 2 },
      { name: 'Ones', step: 1, decimals: 1 },
      { name: 'Tens', step: 10, decimals: 0 },
      { name: 'Hundreds', step: 100, decimals: 0 },
      { name: 'Thousands', step: 1000, decimals: 0 },
      { name: 'Ten Thousands', step: 10000, decimals: 0 },
      { name: 'Hundred Thousands', step: 100000, decimals: 0 },
      { name: 'Millions', step: 1000000, decimals: 0 }
    ];

    let tiles = []; 
    let activeDrawer = 'ones'; 
    let currentTotal = 0;
    let currentZoomIndex = 3;
    let isExpanded = false;
    let currentViewCenter = 0;
    let targetViewCenter = 0;
    let isAnimatingView = false;
    
    // Drag state
    let isDragging = false;
    let dragData = null;
    let dragGhost = null;
    let dragOffset = { x: 0, y: 0 };
    let lastTouchDistance = null;

    // ====== NUMBER LINE ======
    function formatNumberLineLabel(value, decimals) {
      if (decimals <= 1) {
        return Math.abs(value) >= 1000 ? Math.round(value).toLocaleString() : Math.round(value).toString();
      }
      return value.toFixed(decimals - 1);
    }

    function startViewAnimation() {
      if (isAnimatingView) return;
      isAnimatingView = true;
      requestAnimationFrame(animateViewStep);
    }

    function animateViewStep() {
      const diff = targetViewCenter - currentViewCenter;
      if (Math.abs(diff) < 0.0001) {
        currentViewCenter = targetViewCenter;
        renderNumberLine();
        isAnimatingView = false;
        return;
      }
      currentViewCenter += diff * 0.05;
      renderNumberLine();
      if (isAnimatingView) requestAnimationFrame(animateViewStep);
    }

    function renderNumberLine() {
      const numberLine = document.getElementById('numberLine');
      const zoomIndicator = document.getElementById('zoomIndicator');
      numberLine.innerHTML = '';
      
      const zoom = ZOOM_LEVELS[currentZoomIndex];
      const step = zoom.step;
      const decimals = zoom.decimals;
      const visibleRange = step * 10; 
      
      zoomIndicator.style.left = `calc(${(currentZoomIndex / (ZOOM_LEVELS.length - 1)) * 100}% - 2px)`;
      
      let min = currentViewCenter - (visibleRange / 2);
      let max = currentViewCenter + (visibleRange / 2);
      if (min < 0) { min = 0; max = visibleRange; }
      
      const dotPosition = ((currentTotal - min) / (max - min)) * 100;
      const firstMajor = Math.floor(min / step) * step;
      
      for (let v = firstMajor; v <= max + step; v += step) {
        const val = parseFloat(v.toFixed(4));
        if (val < min || val > max) continue;
        
        const posPercent = ((val - min) / (max - min)) * 100;
        const tick = document.createElement('div');
        tick.className = 'tick';
        if (Math.round(val / step) % 5 === 0) tick.classList.add('major');
        tick.style.left = posPercent + '%';
        numberLine.appendChild(tick);
        
        const label = document.createElement('div');
        label.className = 'tick-label';
        label.style.left = posPercent + '%';
        label.textContent = formatNumberLineLabel(val, decimals);
        numberLine.appendChild(label);
      }
      
      if (dotPosition >= -5 && dotPosition <= 105) {
        const valueDot = document.createElement('div');
        valueDot.className = 'value-dot';
        valueDot.style.left = dotPosition + '%';
        const dotLabel = document.createElement('div');
        dotLabel.className = 'dot-label';
        dotLabel.textContent = currentTotal.toLocaleString(undefined, { minimumFractionDigits: 0, maximumFractionDigits: 3 });
        valueDot.appendChild(dotLabel);
        numberLine.appendChild(valueDot);
      }
    }

    function updateNumberLineTarget() {
      const zoom = ZOOM_LEVELS[currentZoomIndex];
      const visibleRange = zoom.step * 10;
      const threshold = visibleRange * 0.35;
      
      if (Math.abs(currentTotal - targetViewCenter) > threshold) {
        targetViewCenter = Math.max(currentTotal, visibleRange / 2);
        startViewAnimation();
      } else if (!isAnimatingView) {
        renderNumberLine();
      }
    }

    function snapNumberLine() {
      const visibleRange = ZOOM_LEVELS[currentZoomIndex].step * 10;
      targetViewCenter = currentViewCenter = Math.max(currentTotal, visibleRange / 2);
      isAnimatingView = false;
      renderNumberLine();
    }

    const numberLineContainer = document.getElementById('numberLineContainer');
    numberLineContainer.addEventListener('wheel', (e) => {
      if (e.ctrlKey) {
        e.preventDefault();
        if (e.deltaY < 0 && currentZoomIndex < ZOOM_LEVELS.length - 1) currentZoomIndex++;
        else if (e.deltaY > 0 && currentZoomIndex > 0) currentZoomIndex--;
        snapNumberLine();
      }
    });
    
    numberLineContainer.addEventListener('touchstart', (e) => {
      if (e.touches.length === 2) lastTouchDistance = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
    });
    numberLineContainer.addEventListener('touchmove', (e) => {
      if (e.touches.length === 2 && lastTouchDistance) {
        e.preventDefault();
        const dist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
        if (Math.abs(dist - lastTouchDistance) > 15) {
          if (dist > lastTouchDistance && currentZoomIndex < ZOOM_LEVELS.length - 1) currentZoomIndex++;
          else if (dist < lastTouchDistance && currentZoomIndex > 0) currentZoomIndex--;
          snapNumberLine();
          lastTouchDistance = dist;
        }
      }
    });
    numberLineContainer.addEventListener('touchend', () => { lastTouchDistance = null; });

    // ====== HELPERS ======
    function getPlaceValueType(value) {
      if (value < 0.01) return 'thousandths';
      if (value < 0.1) return 'hundredths';
      if (value < 1) return 'tenths';
      if (value < 10) return 'ones';
      if (value < 100) return 'tens';
      if (value < 1000) return 'hundreds';
      if (value < 10000) return 'thousands';
      if (value < 100000) return 'tenThousands';
      if (value < 1000000) return 'hundredThousands';
      return 'millions';
    }

    function isDecimalValue(value) { return value < 1; }

    function getDigitsArray(value, showFullDecimal = false) {
      let str;
      if (value < 1) {
        str = value < 0.01 ? value.toFixed(3) : value < 0.1 ? value.toFixed(2) : value.toFixed(1);
        return showFullDecimal ? str.split('') : str.split('.')[1].split('');
      }
      str = String(Math.floor(value));
      const result = [];
      for (let i = 0; i < str.length; i++) {
        result.push(str[i]);
        const posFromRight = str.length - i - 1;
        if (posFromRight > 0 && posFromRight % 3 === 0) result.push(',');
      }
      return result;
    }

    function getPlaceValueOrder(placeValue) {
      return { thousandths: 100, hundredths: 101, tenths: 102, millions: 103, hundredThousands: 104, tenThousands: 105, thousands: 106, hundreds: 107, tens: 108, ones: 109 }[placeValue];
    }

    function getSnapLinePosition(placeValue) {
      const workPane = document.getElementById('workPane');
      const paneRect = workPane.getBoundingClientRect();
      const decimalPoint = document.querySelector('#snapLine .decimal-point');
      const pointRect = decimalPoint.getBoundingClientRect();
      
      const snapY = (paneRect.height / 2) - (BLOCK_HEIGHT / 2);
      const centerX = pointRect.left - paneRect.left + (pointRect.width / 2);
      const DECIMAL_SPACING = 8;
      const EXPAND_GAP = 50; // Space for plus sign
      const scale = getScaleFactor();
      const scaledBlockSize = BLOCK_SIZE * scale;
      
      const decimalPlaces = ['tenths', 'hundredths', 'thousandths'];
      const wholePlaces = ['ones', 'tens', 'hundreds', 'thousands', 'tenThousands', 'hundredThousands', 'millions'];
      const snappedTiles = tiles.filter(t => t.snappedToLine);
      
      if (decimalPlaces.includes(placeValue)) {
        const position = decimalPlaces.indexOf(placeValue);
        if (isExpanded) {
          let offsetX = DECIMAL_SPACING;
          for (let i = 0; i < position; i++) {
            if (snappedTiles.some(t => t.placeValue === decimalPlaces[i])) {
              offsetX += getExpandedCardWidthForPlaceValue(decimalPlaces[i]) + EXPAND_GAP;
            }
          }
          return { x: centerX + offsetX, y: snapY };
        } else {
          const rightEdgeX = centerX + DECIMAL_SPACING + ((position + 1) * scaledBlockSize);
          return { x: rightEdgeX - getCardWidthForSnapped(placeValue, scale), y: snapY };
        }
      } else {
        const position = wholePlaces.indexOf(placeValue);
        if (isExpanded) {
          let offsetX = DECIMAL_SPACING + getExpandedCardWidthForPlaceValue(placeValue);
          for (let i = 0; i < position; i++) {
            if (snappedTiles.some(t => t.placeValue === wholePlaces[i])) {
              offsetX += getExpandedCardWidthForPlaceValue(wholePlaces[i]) + EXPAND_GAP;
            }
          }
          return { x: centerX - offsetX, y: snapY };
        } else {
          return { x: centerX - DECIMAL_SPACING - getCardWidthForSnapped(placeValue, scale), y: snapY };
        }
      }
    }
    
    function getExpandedCardWidthForPlaceValue(placeValue) {
      const values = { tenths: 0.1, hundredths: 0.01, thousandths: 0.001, ones: 1, tens: 10, hundreds: 100, thousands: 1000, tenThousands: 10000, hundredThousands: 100000, millions: 1000000 };
      return getExpandedCardWidth(values[placeValue] || 1);
    }
    
    function getCardWidthForSnapped(placeValue, scale = 1) {
      const decimalDigits = { tenths: 1, hundredths: 2, thousandths: 3 };
      const wholeDigits = { ones: 1, tens: 2, hundreds: 3, thousands: 5, tenThousands: 6, hundredThousands: 7, millions: 9 };
      if (decimalDigits[placeValue]) return decimalDigits[placeValue] * BLOCK_SIZE * scale;
      if (wholeDigits[placeValue]) {
        const commas = placeValue === 'thousands' ? 1 : ['tenThousands', 'hundredThousands'].includes(placeValue) ? 1 : placeValue === 'millions' ? 2 : 0;
        return ((wholeDigits[placeValue] - commas) * BLOCK_SIZE + commas * 14) * scale;
      }
      return BLOCK_SIZE * scale;
    }
    
    function getScaleFactor() {
      const workPane = document.getElementById('workPane');
      if (!workPane) return 1;
      const paneWidth = workPane.getBoundingClientRect().width;
      const snappedTiles = tiles.filter(t => t.snappedToLine);
      if (snappedTiles.length === 0) return 1;
      
      let totalWidth = 50;
      if (isExpanded) {
        snappedTiles.forEach((t, i) => {
          totalWidth += getExpandedCardWidthForPlaceValue(t.placeValue);
          if (i < snappedTiles.length - 1) totalWidth += 50; // Match EXPAND_GAP
        });
      } else {
        const decimalPlaces = ['tenths', 'hundredths', 'thousandths'];
        let wholeSlots = 0, decimalSlots = 0;
        snappedTiles.forEach(t => {
          if (decimalPlaces.includes(t.placeValue)) decimalSlots = Math.max(decimalSlots, decimalPlaces.indexOf(t.placeValue) + 1);
          else wholeSlots = Math.max(wholeSlots, ['ones', 'tens', 'hundreds', 'thousands', 'tenThousands', 'hundredThousands', 'millions'].indexOf(t.placeValue) + 1);
        });
        totalWidth = (wholeSlots + decimalSlots) * BLOCK_SIZE + 50;
      }
      return totalWidth > paneWidth * 0.9 ? (paneWidth * 0.9) / totalWidth : 1;
    }
    
    function getExpandedCardWidth(value) {
      return getDigitsArray(value, true).reduce((w, c) => w + (c === ',' || c === '.' ? 14 : BLOCK_SIZE), 0);
    }

    // ====== CREATE TILE ELEMENT ======
    function createTileElement(value, showFullDecimal) {
      const el = document.createElement('div');
      const isDecimal = isDecimalValue(value);
      const digits = getDigitsArray(value, showFullDecimal);
      el.className = `tile${isDecimal ? ' decimal-tile' : ''}`;
      digits.forEach(char => {
        const d = document.createElement('div');
        d.className = char === ',' ? 'digit-block comma-block' : char === '.' ? 'digit-block decimal-block' : 'digit-block';
        d.textContent = char;
        el.appendChild(d);
      });
      return el;
    }

    // ====== RENDER ======
    function renderActiveDrawer() {
      const baseRow = document.getElementById('baseRow');
      baseRow.innerHTML = '';
      (PLACE_VALUES[activeDrawer] || []).forEach(val => {
        const tile = createTileElement(val, isDecimalValue(val));
        tile.dataset.value = val;
        tile.addEventListener('pointerdown', (e) => startDrag(e, val, 'tray'));
        baseRow.appendChild(tile);
      });
    }

    function renderWorkPane() {
      const workPane = document.getElementById('workPane');
      workPane.querySelectorAll('.work-pane-tile, .plus-sign').forEach(el => el.remove());
      
      let sum = 0;
      const scale = getScaleFactor();
      
      tiles.forEach(tile => {
        if (tile.snappedToLine) {
          const pos = getSnapLinePosition(tile.placeValue);
          tile.x = pos.x;
          tile.y = pos.y;
        }
      });
      
      const sortedTiles = [...tiles].sort((a, b) => a.zIndex - b.zIndex);
      const snappedTiles = sortedTiles.filter(t => t.snappedToLine);

      sortedTiles.forEach(tile => {
        sum += tile.value;
        const isDecimal = isDecimalValue(tile.value);
        const showFull = !tile.snappedToLine || isExpanded;
        const digits = getDigitsArray(tile.value, isDecimal && showFull);

        const el = document.createElement('div');
        el.className = `tile work-pane-tile${isDecimal ? ' decimal-tile' : ''}`;
        el.style.cssText = `left:${tile.x}px;top:${tile.y}px;z-index:${tile.zIndex}`;
        if (tile.snappedToLine && scale < 1) {
          el.style.transform = `scale(${scale})`;
          el.style.transformOrigin = isDecimal ? 'left center' : 'right center';
        }
        digits.forEach(char => {
          const d = document.createElement('div');
          d.className = char === ',' ? 'digit-block comma-block' : char === '.' ? 'digit-block decimal-block' : 'digit-block';
          d.textContent = char;
          el.appendChild(d);
        });
        el.addEventListener('pointerdown', (e) => startDrag(e, tile.value, tile.id));
        workPane.appendChild(el);
      });
      
      // Plus signs for expanded view
      if (isExpanded && snappedTiles.length > 1) {
        const paneHeight = workPane.getBoundingClientRect().height;
        const plusY = (paneHeight / 2) - (BLOCK_HEIGHT / 2);
        const decimalPoint = document.querySelector('#snapLine .decimal-point');
        const pointRect = decimalPoint.getBoundingClientRect();
        const paneRect = workPane.getBoundingClientRect();
        const decimalCenterX = pointRect.left - paneRect.left + (pointRect.width / 2);
        
        // Separate tiles into wholes and decimals
        const wholeTiles = snappedTiles.filter(t => !isDecimalValue(t.value)).sort((a, b) => b.x - a.x); // right to left
        const decimalTiles = snappedTiles.filter(t => isDecimalValue(t.value)).sort((a, b) => a.x - b.x); // left to right
        
        // Plus signs between whole number cards (right to left, so between each pair)
        for (let i = 0; i < wholeTiles.length - 1; i++) {
          const leftTile = wholeTiles[i + 1];
          const plusX = leftTile.x + getExpandedCardWidth(leftTile.value) + 10;
          
          const plus = document.createElement('div');
          plus.className = 'plus-sign';
          plus.textContent = '+';
          plus.style.left = plusX + 'px';
          plus.style.top = plusY + 'px';
          workPane.appendChild(plus);
        }
        
        // Plus sign over the decimal point (if both wholes and decimals exist)
        if (wholeTiles.length > 0 && decimalTiles.length > 0) {
          const plus = document.createElement('div');
          plus.className = 'plus-sign';
          plus.textContent = '+';
          plus.style.left = (decimalCenterX - 15) + 'px'; // Center the plus sign
          plus.style.top = plusY + 'px';
          workPane.appendChild(plus);
        }
        
        // Plus signs between decimal cards (left to right)
        for (let i = 0; i < decimalTiles.length - 1; i++) {
          const leftTile = decimalTiles[i];
          const plusX = leftTile.x + getExpandedCardWidth(leftTile.value) + 10;
          
          const plus = document.createElement('div');
          plus.className = 'plus-sign';
          plus.textContent = '+';
          plus.style.left = plusX + 'px';
          plus.style.top = plusY + 'px';
          workPane.appendChild(plus);
        }
      }
      
      updateTotal(sum);
    }

    function updateTotal(val) {
      currentTotal = parseFloat(val.toFixed(4));
      document.getElementById('sumText').textContent = new Intl.NumberFormat('en-US').format(currentTotal);
      updateNumberLineTarget();
    }

    // ====== DRAG SYSTEM ======
    function startDrag(e, value, source) {
      e.preventDefault();
      e.stopPropagation();
      
      const rect = e.currentTarget.getBoundingClientRect();
      const placeValue = getPlaceValueType(value);
      const isDecimal = isDecimalValue(value);
      
      // Store drag data
      dragData = {
        value,
        placeValue,
        source, // 'tray' or tile id
        isDecimal
      };
      
      // Calculate offset from cursor to card top-left
      dragOffset = {
        x: e.clientX - rect.left,
        y: e.clientY - rect.top
      };
      
      // Create the ghost immediately
      dragGhost = createTileElement(value, isDecimal);
      dragGhost.classList.add('drag-ghost');
      document.body.appendChild(dragGhost);
      
      // Position ghost at cursor
      updateGhostPosition(e.clientX, e.clientY);
      
      isDragging = true;
      
      // Set up move and end listeners
      document.addEventListener('pointermove', onDragMove);
      document.addEventListener('pointerup', onDragEnd);
      document.addEventListener('pointercancel', onDragEnd);
    }
    
    function updateGhostPosition(clientX, clientY) {
      if (!dragGhost) return;
      const x = clientX - dragOffset.x;
      const y = clientY - dragOffset.y;
      dragGhost.style.left = x + 'px';
      dragGhost.style.top = y + 'px';
    }
    
    function onDragMove(e) {
      if (!isDragging) return;
      e.preventDefault();
      updateGhostPosition(e.clientX, e.clientY);
    }
    
    function onDragEnd(e) {
      if (!isDragging) return;
      
      document.removeEventListener('pointermove', onDragMove);
      document.removeEventListener('pointerup', onDragEnd);
      document.removeEventListener('pointercancel', onDragEnd);
      
      // Remove ghost
      if (dragGhost) {
        dragGhost.remove();
        dragGhost = null;
      }
      
      // Determine drop location
      const workPane = document.getElementById('workPane');
      const paneRect = workPane.getBoundingClientRect();
      
      if (e.clientY >= paneRect.top && e.clientY <= paneRect.bottom) {
        const dropY = e.clientY - paneRect.top;
        const centerY = paneRect.height / 2;
        const snapZone = BLOCK_HEIGHT * 1.5;
        const touchingLine = Math.abs(dropY - centerY) < snapZone;
        
        const snapPos = getSnapLinePosition(dragData.placeValue);
        const order = getPlaceValueOrder(dragData.placeValue);
        const zIndex = 1000 + order;
        
        let finalX, finalY, snappedToLine;
        
        if (touchingLine) {
          finalX = snapPos.x;
          finalY = snapPos.y;
          snappedToLine = true;
          
          // Remove existing tile of same place value from snap line
          tiles = tiles.filter(t => {
            if (t.id === dragData.source) return true; // Keep if we're moving this tile
            return !(t.placeValue === dragData.placeValue && t.snappedToLine);
          });
        } else {
          finalX = e.clientX - paneRect.left - dragOffset.x;
          finalY = dropY - dragOffset.y;
          snappedToLine = false;
        }
        
        if (dragData.source === 'tray') {
          // Add new tile
          tiles.push({
            id: Date.now() + Math.random(),
            value: dragData.value,
            placeValue: dragData.placeValue,
            x: finalX,
            y: finalY,
            snappedToLine,
            zIndex
          });
        } else {
          // Move existing tile
          const existing = tiles.find(t => t.id === dragData.source);
          if (existing) {
            existing.x = finalX;
            existing.y = finalY;
            existing.snappedToLine = snappedToLine;
            existing.zIndex = zIndex;
          }
        }
      } else if (dragData.source !== 'tray') {
        // Dropped outside workspace - remove tile
        tiles = tiles.filter(t => t.id !== dragData.source);
      }
      
      isDragging = false;
      dragData = null;
      
      renderWorkPane();
    }

    // ====== EVENT LISTENERS ======
    document.getElementById('speakBtn').addEventListener('click', () => {
      const utterance = new SpeechSynthesisUtterance(currentTotal.toString());
      utterance.rate = 0.9;
      window.speechSynthesis.speak(utterance);
    });

    document.getElementById('expandBtn').addEventListener('click', () => {
      if (tiles.filter(t => t.snappedToLine).length === 0) return;
      isExpanded = !isExpanded;
      document.getElementById('expandBtn').innerHTML = isExpanded 
        ? '<span class="btn-icon">ðŸ”—</span> Collapse' 
        : '<span class="btn-icon">ðŸ’¥</span> Expand';
      renderWorkPane();
    });

    document.querySelectorAll('.drawer-tab').forEach(tab => {
      tab.addEventListener('click', () => {
        activeDrawer = tab.dataset.drawer;
        document.querySelectorAll('.drawer-tab').forEach(t => {
          t.classList.toggle('active', t === tab);
          if(t === tab) t.scrollIntoView({behavior: 'smooth', inline: 'center'});
        });
        renderActiveDrawer();
      });
    });

    document.getElementById('resetBtn').addEventListener('click', () => {
      tiles = [];
      isExpanded = false;
      document.getElementById('expandBtn').innerHTML = '<span class="btn-icon">ðŸ’¥</span> Expand';
      renderWorkPane();
    });

    // Start
    renderActiveDrawer();
    renderWorkPane();
    snapNumberLine();
  </script>
</body>
</html>
