<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"/>
  <title>Place Value: Resource Edition</title>
  <link href="https://fonts.googleapis.com/css2?family=Lexend:wght@400;700;900&display=swap" rel="stylesheet"/>
  <style>
    *{margin:0;padding:0;box-sizing:border-box}
    :root{
      --bg:#f3f4f6; 
      --ink:#111827;
      --tray:#1f2937; 
      --accent:#3b82f6;
      --block-size: 60px;
      --block-height: 110px;
      
      /* Montessori Colors */
      --c-ones: #16a34a; 
      --c-tens: #2563eb;
      --c-hundreds: #dc2626;
      --c-tenths: #93c5fd; 
      --c-hundredths: #fca5a5; 
      --c-thousandths: #86efac;
    }

    body{font-family:'Lexend',sans-serif;background:var(--bg);color:var(--ink);height:100vh;overflow:hidden;touch-action:manipulation; user-select: none;}

    #app{position:relative;height:calc(100% - 60px);width:100%; display:flex; flex-direction:column;}

    /* === TOP DASHBOARD === */
    #dashboard {
      height: 60px;
      background: white;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 20px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      z-index: 50;
    }

    .dash-group { display: flex; align-items: center; gap: 15px; }

    /* Total Display */
    #totalDisplay {
      font-size: 24px;
      font-weight: 900;
      color: #374151;
      background: #f3f4f6;
      padding: 5px 20px;
      border-radius: 30px;
      min-width: 100px;
      text-align: center;
      border: 2px solid #e5e7eb;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    /* Controls */
    .btn {
      border: none;
      background: #374151;
      color: white;
      padding: 8px 16px;
      border-radius: 8px;
      font-weight: 700;
      font-family: inherit;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 8px;
      transition: transform 0.1s, background 0.2s;
      font-size: 14px;
    }
    .btn:hover { background: #1f2937; transform: translateY(-1px); }
    .btn:active { transform: translateY(1px); }
    
    .btn-icon { font-size: 18px; }
    .btn-primary { background: var(--accent); }
    .btn-primary:hover { background: #2563eb; }
    .btn-danger { background: #ef4444; }
    .btn-danger:hover { background: #dc2626; }
    .btn-success { background: #10b981; }
    
    /* Challenge Banner */
    #challengeBanner {
      position: absolute;
      top: 70px;
      left: 50%;
      transform: translateX(-50%);
      background: #1f2937;
      color: #facc15;
      padding: 10px 24px;
      border-radius: 50px;
      font-weight: 900;
      font-size: 20px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
      z-index: 40;
      display: none;
      animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    }
    @keyframes popIn { from{transform:translate(-50%, -20px) scale(0.9); opacity:0;} to{transform:translate(-50%, 0) scale(1); opacity:1;} }

    /* === NUMBER LINE PANEL === */
    #numberLinePanel {
      background: white;
      border-bottom: 1px solid #e5e7eb;
      padding: 15px 20px;
      z-index: 45;
    }
    
    .zoom-bar-container {
      margin-bottom: 10px;
    }
    
    .zoom-bar {
      position: relative;
      height: 8px;
      background: linear-gradient(to right, #3498db, #9b59b6, #e74c3c);
      border-radius: 4px;
      margin-bottom: 5px;
    }
    
    .zoom-indicator {
      position: absolute;
      top: -4px;
      width: 4px;
      height: 16px;
      background: #2c3e50;
      border-radius: 2px;
      transition: left 0.3s ease;
      box-shadow: 0 2px 4px rgba(0,0,0,0.3);
    }
    
    .zoom-labels {
      display: flex;
      justify-content: space-between;
      font-size: 0.65rem;
      color: #9ca3af;
    }
    
    .number-line-container {
      position: relative;
      height: 70px;
      cursor: ns-resize;
    }
    
    .number-line {
      width: 100%;
      height: 50px;
      position: relative;
      background: linear-gradient(to bottom, transparent 46%, #2c3e50 46%, #2c3e50 54%, transparent 54%);
    }
    
    .tick {
      position: absolute;
      top: 20%;
      width: 2px;
      height: 60%;
      background: #d1d5db;
      transform: translateX(-50%);
    }
    
    .tick.major {
      top: 10%;
      width: 3px;
      height: 80%;
      background: #6b7280;
    }
    
    .tick-label {
      position: absolute;
      top: 55px;
      transform: translateX(-50%);
      font-weight: 700;
      font-size: 0.8rem;
      color: #374151;
      white-space: nowrap;
    }
    
    .value-dot {
      position: absolute;
      width: 20px;
      height: 20px;
      background: #e74c3c;
      border: 3px solid white;
      border-radius: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      z-index: 10;
      box-shadow: 0 3px 8px rgba(0,0,0,0.3);
      transition: left 0.3s ease;
    }
    
    .dot-label {
      position: absolute;
      top: -28px;
      left: 50%;
      transform: translateX(-50%);
      background: #e74c3c;
      color: white;
      padding: 3px 8px;
      border-radius: 5px;
      font-weight: 700;
      font-size: 0.75rem;
      white-space: nowrap;
      box-shadow: 0 2px 6px rgba(0,0,0,0.2);
    }
    
    .dot-label::after {
      content: '';
      position: absolute;
      bottom: -5px;
      left: 50%;
      transform: translateX(-50%);
      border-left: 5px solid transparent;
      border-right: 5px solid transparent;
      border-top: 5px solid #e74c3c;
    }
    
    .zoom-hint {
      text-align: center;
      font-size: 0.7rem;
      color: #9ca3af;
      margin-top: 5px;
    }

    /* === WORKSPACE === */
    #workPane{
      flex: 1;
      position:relative;
      background:radial-gradient(circle at center, #ffffff 0%, #f3f4f6 100%);
      overflow:hidden;
    }
    
    #snapLine{
      position:absolute;
      top:50%;
      left:0; right:0;
      height:4px;
      background:rgba(0,0,0,0.1);
      pointer-events:none;
      z-index:5;
    }
    #snapLine .decimal-point {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      font-size: 80px;
      font-weight: 900;
      color: #111827;
      text-shadow: 0 2px 0 rgba(255,255,255,1);
      line-height: 1;
      margin-top: -10px;
    }

    /* === MULTIPLICATION CHART MODAL === */
    #multChart {
      position: absolute;
      top: 80px; right: 20px;
      background: white;
      padding: 15px;
      border-radius: 12px;
      box-shadow: 0 10px 25px rgba(0,0,0,0.2);
      z-index: 100;
      display: none;
    }
    .chart-grid {
      display: grid;
      grid-template-columns: repeat(11, 1fr);
      gap: 2px;
      font-size: 12px;
    }
    .chart-cell {
      width: 30px; height: 30px;
      display: flex; align-items: center; justify-content: center;
      background: #f3f4f6;
      border-radius: 4px;
      font-weight: 600;
    }
    .chart-header { background: #374151; color: white; }

    /* === BOTTOM DOCK === */
    #bottomDock{
      height: 28vh;
      background: var(--tray);
      display: flex; flex-direction: column;
      z-index: 60;
      box-shadow: 0 -4px 20px rgba(0,0,0,0.15);
    }

    #drawerTabs{
      display:flex;
      background:#374151;
      overflow-x:auto;
      padding: 0 10px;
      scrollbar-width: none;
    }
    #drawerTabs::-webkit-scrollbar { display: none; }

    .drawer-tab{
      padding:10px 16px;
      background:transparent; color: #9ca3af;
      border:none; cursor:pointer;
      font-weight:700; font-size:12px;
      white-space:nowrap; transition:all .2s;
      border-bottom: 3px solid transparent;
    }
    .drawer-tab.active{
      color: white; background: rgba(255,255,255,0.1);
      border-bottom: 3px solid var(--accent);
    }

    #baseTiles{
      flex:1;
      padding:15px;
      overflow-x: auto; overflow-y: hidden;
      display:flex; align-items:center;
    }
    .base-row{ display:flex; gap:12px; margin: 0 auto; }

    /* === TILES === */
    .tile{
      height:var(--block-height);
      display:flex;
      cursor:grab;
      border-radius:8px;
      box-shadow: 4px 4px 0 rgba(0,0,0,0.2);
      background: white;
      overflow:hidden;
      transition: transform 0.1s;
    }
    .tile:active{ cursor:grabbing; transform: scale(1.02); }
    .tile.dragging{ position:fixed; z-index: 9999; opacity:0.9; pointer-events:none; }
    .work-pane-tile{ position:absolute; transition: left 0.2s, top 0.2s; }

    .digit-block{
      width:var(--block-size); height:var(--block-height);
      display:flex; align-items:center; justify-content:center;
      font-weight:800; font-size:48px; line-height:1;
    }
    .comma-block{ width:20px; align-items:flex-end; padding-bottom:15px; }

    /* Colors */
    .pv-ones, .pv-thousands, .pv-millions { background: var(--c-ones); color: white; }
    .pv-tens, .pv-tenThousands { background: var(--c-tens); color: white; }
    .pv-hundreds, .pv-hundredThousands { background: var(--c-hundreds); color: white; }
    .pv-tenths { background: var(--c-tenths); color: #1e3a8a; }
    .pv-hundredths { background: var(--c-hundredths); color: #7f1d1d; }
    .pv-thousandths { background: var(--c-thousandths); color: #14532d; }

    /* Confetti */
    .confetti { position: absolute; width: 10px; height: 10px; background: #f00; animation: fall linear forwards; pointer-events: none; z-index: 9999; }
    @keyframes fall { to { transform: translateY(100vh) rotate(720deg); } }

  </style>
</head>
<body>

  <!-- Dashboard -->
  <div id="dashboard">
    <div class="dash-group">
      <button class="btn btn-danger" id="resetBtn"><span class="btn-icon">üóë</span> Clear</button>
      <div id="totalDisplay">
        <span id="sumText">0</span>
        <button class="btn btn-primary" id="speakBtn" style="padding:4px 8px; border-radius:20px; min-width:auto;" title="Read Aloud">üîä</button>
      </div>
    </div>
    
    <div class="dash-group">
      <button class="btn" id="toggleChartBtn"><span class="btn-icon">‚úñÔ∏è</span> Chart</button>
      <button class="btn btn-success" id="challengeBtn"><span class="btn-icon">üéØ</span> Challenge</button>
    </div>
  </div>

  <!-- Challenge Banner -->
  <div id="challengeBanner">Target: <span id="targetNum">0</span></div>

  <!-- Multiplication Chart Popup -->
  <div id="multChart">
    <div class="chart-grid" id="gridContainer"></div>
  </div>

  <div id="app">
    <!-- Number Line Panel -->
    <div id="numberLinePanel">
      <div class="zoom-bar-container">
        <div class="zoom-bar">
          <div class="zoom-indicator" id="zoomIndicator"></div>
        </div>
        <div class="zoom-labels">
          <span>0.01</span>
          <span>0.1</span>
          <span>1</span>
          <span>10</span>
          <span>100</span>
          <span>1K</span>
          <span>10K</span>
          <span>100K</span>
          <span>1M</span>
        </div>
      </div>
      <div class="number-line-container" id="numberLineContainer">
        <div class="number-line" id="numberLine"></div>
      </div>
      <div class="zoom-hint">Ctrl+scroll or pinch to zoom</div>
    </div>

    <div id="workPane">
      <div id="snapLine"><span class="decimal-point">.</span></div>
    </div>

    <div id="bottomDock">
      <div id="drawerTabs">
        <button class="drawer-tab" data-drawer="millions">Millions</button>
        <button class="drawer-tab" data-drawer="hundredThousands">H. Thousands</button>
        <button class="drawer-tab" data-drawer="tenThousands">T. Thousands</button>
        <button class="drawer-tab" data-drawer="thousands">Thousands</button>
        <button class="drawer-tab" data-drawer="hundreds">Hundreds</button>
        <button class="drawer-tab" data-drawer="tens">Tens</button>
        <button class="drawer-tab active" data-drawer="ones">Ones</button>
        <button class="drawer-tab" data-drawer="tenths">Tenths</button>
        <button class="drawer-tab" data-drawer="hundredths">Hundredths</button>
      </div>
      <div id="baseTiles">
        <div class="base-row" id="baseRow"></div>
      </div>
    </div>
  </div>

  <script>
    // ====== CONFIG ======
    const BLOCK_SIZE = 60;
    const BLOCK_HEIGHT = 110;
    const SNAP_DISTANCE = 40;
    const SNAP_LINE_DISTANCE = 80; 
    
    const PLACE_VALUES = {
      tenths: [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9],
      hundredths: [0.01, 0.02, 0.03, 0.04, 0.05, 0.06, 0.07, 0.08, 0.09],
      ones: [1, 2, 3, 4, 5, 6, 7, 8, 9],
      tens: [10, 20, 30, 40, 50, 60, 70, 80, 90],
      hundreds: [100, 200, 300, 400, 500, 600, 700, 800, 900],
      thousands: [1000, 2000, 3000, 4000, 5000, 6000, 7000, 8000, 9000],
      tenThousands: [10000, 20000, 30000, 40000, 50000, 60000, 70000, 80000, 90000],
      hundredThousands: [100000, 200000, 300000, 400000, 500000, 600000, 700000, 800000, 900000],
      millions: [1000000, 2000000, 3000000, 4000000, 5000000, 6000000, 7000000, 8000000, 9000000]
    };

    // ====== NUMBER LINE CONFIG ======
    const ZOOM_LEVELS = [
      { name: 'Hundredths', step: 0.01, decimals: 3 },
      { name: 'Tenths', step: 0.1, decimals: 2 },
      { name: 'Ones', step: 1, decimals: 1 },
      { name: 'Tens', step: 10, decimals: 0 },
      { name: 'Hundreds', step: 100, decimals: 0 },
      { name: 'Thousands', step: 1000, decimals: 0 },
      { name: 'Ten Thousands', step: 10000, decimals: 0 },
      { name: 'Hundred Thousands', step: 100000, decimals: 0 },
      { name: 'Millions', step: 1000000, decimals: 0 }
    ];

    // ====== STATE ======
    let tiles = []; 
    let activeDrawer = 'ones'; 
    let currentTotal = 0;
    let challengeMode = false;
    let targetNumber = 0;
    let currentZoomIndex = 2; // Start at Ones

    // Drag State
    let draggedTile = null;
    let dragOffset = {x: 0, y: 0};
    let gesture = null;
    let lastTouchDistance = null;

    // ====== NUMBER LINE FUNCTIONS ======
    function getSensibleZoomIndex(value) {
      if (value === 0) return 2; // Ones
      
      // Find the magnitude of the number
      const absVal = Math.abs(value);
      
      if (absVal < 0.1) return 0;      // Hundredths
      if (absVal < 1) return 1;         // Tenths
      if (absVal < 10) return 2;        // Ones
      if (absVal < 100) return 3;       // Tens
      if (absVal < 1000) return 4;      // Hundreds
      if (absVal < 10000) return 5;     // Thousands
      if (absVal < 100000) return 6;    // Ten Thousands
      if (absVal < 1000000) return 7;   // Hundred Thousands
      return 8;                          // Millions
    }

    function formatNumberLineLabel(value, decimals) {
      // Ones and above: no decimal points
      if (decimals <= 1) {
        if (Math.abs(value) >= 1000) {
          return Math.round(value).toLocaleString();
        }
        return Math.round(value).toString();
      }
      // Decimal zoom levels
      return value.toFixed(decimals - 1);
    }

    function formatDotLabel(value, decimals) {
      if (decimals <= 1) {
        if (Math.abs(value) >= 1000) {
          return value.toLocaleString(undefined, { maximumFractionDigits: 0 });
        }
        return Math.round(value).toString();
      }
      return value.toFixed(decimals - 1);
    }

    function updateNumberLine() {
      const numberLine = document.getElementById('numberLine');
      const zoomIndicator = document.getElementById('zoomIndicator');
      numberLine.innerHTML = '';
      
      const zoom = ZOOM_LEVELS[currentZoomIndex];
      const step = zoom.step;
      const decimals = zoom.decimals;
      const visibleRange = step * 10;
      
      // Update zoom indicator
      const indicatorPosition = (currentZoomIndex / (ZOOM_LEVELS.length - 1)) * 100;
      zoomIndicator.style.left = `calc(${indicatorPosition}% - 2px)`;
      
      // Calculate visible window - centered on value, but min can't go below 0
      let min = currentTotal - (visibleRange / 2);
      let max = currentTotal + (visibleRange / 2);
      
      if (min < 0) {
        min = 0;
        max = visibleRange;
      }
      
      // Dot position
      const dotPosition = ((currentTotal - min) / visibleRange) * 100;
      
      // Draw 11 ticks
      for (let i = 0; i <= 10; i++) {
        const tickValue = min + (visibleRange * (i / 10));
        const position = (i / 10) * 100;
        
        const tick = document.createElement('div');
        tick.className = 'tick';
        if (i === 0 || i === 5 || i === 10) {
          tick.classList.add('major');
        }
        tick.style.left = position + '%';
        numberLine.appendChild(tick);
      }
      
      // Labels at 0%, 50%, 100%
      [0, 5, 10].forEach(i => {
        const tickValue = min + (visibleRange * (i / 10));
        const position = (i / 10) * 100;
        
        const label = document.createElement('div');
        label.className = 'tick-label';
        label.style.left = position + '%';
        label.textContent = formatNumberLineLabel(tickValue, decimals);
        numberLine.appendChild(label);
      });
      
      // Value dot with label
      const valueDot = document.createElement('div');
      valueDot.className = 'value-dot';
      valueDot.style.left = Math.max(0, Math.min(100, dotPosition)) + '%';
      
      const dotLabel = document.createElement('div');
      dotLabel.className = 'dot-label';
      dotLabel.textContent = formatDotLabel(currentTotal, decimals);
      valueDot.appendChild(dotLabel);
      
      numberLine.appendChild(valueDot);
    }

    // Number line zoom controls
    const numberLineContainer = document.getElementById('numberLineContainer');
    
    numberLineContainer.addEventListener('wheel', (e) => {
      if (e.ctrlKey) {
        e.preventDefault();
        if (e.deltaY < 0 && currentZoomIndex < ZOOM_LEVELS.length - 1) {
          currentZoomIndex++;
          updateNumberLine();
        } else if (e.deltaY > 0 && currentZoomIndex > 0) {
          currentZoomIndex--;
          updateNumberLine();
        }
      }
    });
    
    numberLineContainer.addEventListener('touchstart', (e) => {
      if (e.touches.length === 2) {
        lastTouchDistance = getTouchDistance(e.touches);
      }
    });
    
    numberLineContainer.addEventListener('touchmove', (e) => {
      if (e.touches.length === 2 && lastTouchDistance) {
        e.preventDefault();
        const currentDistance = getTouchDistance(e.touches);
        const delta = currentDistance - lastTouchDistance;
        
        if (Math.abs(delta) > 15) {
          if (delta > 0 && currentZoomIndex < ZOOM_LEVELS.length - 1) {
            currentZoomIndex++;
            updateNumberLine();
          } else if (delta < 0 && currentZoomIndex > 0) {
            currentZoomIndex--;
            updateNumberLine();
          }
          lastTouchDistance = currentDistance;
        }
      }
    });
    
    numberLineContainer.addEventListener('touchend', () => {
      lastTouchDistance = null;
    });
    
    function getTouchDistance(touches) {
      const dx = touches[0].clientX - touches[1].clientX;
      const dy = touches[0].clientY - touches[1].clientY;
      return Math.sqrt(dx * dx + dy * dy);
    }

    // ====== INIT HELPERS ======
    function buildMultChart() {
      const grid = document.getElementById('gridContainer');
      grid.appendChild(createCell('√ó', 'chart-header'));
      for(let i=1; i<=10; i++) grid.appendChild(createCell(i, 'chart-header'));
      for(let r=1; r<=10; r++) {
        grid.appendChild(createCell(r, 'chart-header'));
        for(let c=1; c<=10; c++) {
          grid.appendChild(createCell(r*c, 'chart-cell'));
        }
      }
    }
    function createCell(text, cls) {
      const d = document.createElement('div');
      d.className = `chart-cell ${cls}`;
      d.textContent = text;
      return d;
    }

    // ====== CORE LOGIC ======
    function getPlaceValueType(value) {
      if (value < 0.01) return 'thousandths';
      if (value < 0.1) return 'hundredths';
      if (value < 1) return 'tenths';
      if (value < 10) return 'ones';
      if (value < 100) return 'tens';
      if (value < 1000) return 'hundreds';
      if (value < 10000) return 'thousands';
      if (value < 100000) return 'tenThousands';
      if (value < 1000000) return 'hundredThousands';
      return 'millions';
    }

    function getVisualClass(type) { return `pv-${type}`; }

    function getDigitsArray(value, forTray = false) {
      let str;
      if (value < 1) {
        // For decimal values, just return the digit(s) - no leading decimal
        if (value < 0.01) str = value.toFixed(3);
        else if (value < 0.1) str = value.toFixed(2);
        else str = value.toFixed(1);
        const parts = str.split('.');
        return parts[1].split(''); // Just the decimal digits, no dot
      } else {
        str = String(Math.floor(value));
      }
      
      const result = [];
      const wholeDigits = str.split('');
      for (let i = 0; i < wholeDigits.length; i++) {
        result.push(wholeDigits[i]);
        const posFromRight = wholeDigits.length - i - 1;
        if (posFromRight > 0 && posFromRight % 3 === 0) result.push(',');
      }
      return result;
    }

    function getCardWidth(placeValue) {
      const sampleVal = PLACE_VALUES[placeValue][0];
      const digits = getDigitsArray(sampleVal);
      let width = 0;
      for (let char of digits) {
        if (char === ',') width += 20;
        else width += BLOCK_SIZE;
      }
      return width;
    }

    function getPlaceValueOrder(placeValue) {
      const order = { 
        thousandths: 1, hundredths: 2, tenths: 3,
        millions: 4, hundredThousands: 5, tenThousands: 6, 
        thousands: 7, hundreds: 8, tens: 9, ones: 10
      };
      return order[placeValue];
    }

    function getSnapLinePosition(placeValue) {
      const workPane = document.getElementById('workPane');
      const paneRect = workPane.getBoundingClientRect();
      const snapLine = document.getElementById('snapLine');
      const decimalPoint = snapLine.querySelector('.decimal-point');
      const pointRect = decimalPoint.getBoundingClientRect();
      
      const snapY = (paneRect.height / 2) - (BLOCK_HEIGHT / 2);
      const centerX = pointRect.left - paneRect.left + (pointRect.width / 2);
      const cardWidth = getCardWidth(placeValue);
      
      const isDecimal = ['thousandths','hundredths','tenths'].includes(placeValue);
      // Whole numbers snap to LEFT of decimal, decimals snap to RIGHT
      return isDecimal ? { x: centerX + 5, y: snapY } : { x: centerX - cardWidth - 5, y: snapY };
    }

    function findOverlayTarget(dropX, dropY, droppedPlaceValue, excludeId) {
      const droppedOrder = getPlaceValueOrder(droppedPlaceValue);
      const droppedWidth = getCardWidth(droppedPlaceValue);
      let bestMatch = null;
      let bestDistance = Infinity;

      for (const tile of tiles) {
        if (tile.id === excludeId) continue;
        if (Math.abs(tile.y - dropY) > 50) continue;

        const targetOrder = getPlaceValueOrder(tile.placeValue);
        const droppedIsDecimal = ['thousandths','hundredths','tenths'].includes(droppedPlaceValue);
        const targetIsDecimal = ['thousandths','hundredths','tenths'].includes(tile.placeValue);
        
        let canOverlay = false;
        let snapX, snapY;
        
        if (!droppedIsDecimal && !targetIsDecimal && droppedOrder > targetOrder) {
          canOverlay = true;
          const targetWidth = getCardWidth(tile.placeValue);
          snapX = tile.x + targetWidth - droppedWidth;
          snapY = tile.y;
        } 
        else if (droppedIsDecimal && !targetIsDecimal) {
          canOverlay = true;
          const targetWidth = getCardWidth(tile.placeValue);
          snapX = tile.x + targetWidth; 
          snapY = tile.y;
        } 
        else if (droppedIsDecimal && targetIsDecimal && droppedOrder > targetOrder) {
          canOverlay = true;
          snapX = tile.x; 
          snapY = tile.y;
        }
        
        if (!canOverlay) continue;

        const dist = Math.sqrt(Math.pow(dropX - snapX, 2) + Math.pow(dropY - snapY, 2));
        if (dist < SNAP_DISTANCE && dist < bestDistance) {
          bestDistance = dist;
          bestMatch = { tile, snapX, snapY };
        }
      }
      return bestMatch;
    }

    // ====== DOM & RENDER ======
    function createTile(value, source) {
      const el = document.createElement('div');
      const placeValue = getPlaceValueType(value);
      const digits = getDigitsArray(value);
      const colorClass = getVisualClass(placeValue);

      el.className = `tile ${colorClass}`;
      el.dataset.value = value;
      
      digits.forEach(char => {
        const d = document.createElement('div');
        if (char === ',') { 
          d.className = 'digit-block comma-block'; 
          d.textContent = ','; 
        } else { 
          d.className = 'digit-block'; 
          d.textContent = char; 
        }
        el.appendChild(d);
      });

      el.addEventListener('pointerdown', (e) => onPointerStart(e, value, source));
      return el;
    }

    function renderActiveDrawer() {
      const baseRow = document.getElementById('baseRow');
      baseRow.innerHTML = '';
      (PLACE_VALUES[activeDrawer] || []).forEach(val => {
        baseRow.appendChild(createTile(val, 'tray'));
      });
    }

    function renderWorkPane() {
      const workPane = document.getElementById('workPane');
      workPane.querySelectorAll('.work-pane-tile').forEach(el => el.remove());
      
      let sum = 0;
      const sortedTiles = [...tiles].sort((a, b) => a.zIndex - b.zIndex);

      sortedTiles.forEach(tile => {
        sum += tile.value;
        const digits = getDigitsArray(tile.value);
        const colorClass = getVisualClass(tile.placeValue);

        const el = document.createElement('div');
        el.className = `tile work-pane-tile ${colorClass}`;
        el.style.left = tile.x + 'px';
        el.style.top = tile.y + 'px';
        el.style.zIndex = tile.zIndex;
        
        digits.forEach(char => {
          const d = document.createElement('div');
          if (char === ',') { 
            d.className = 'digit-block comma-block'; 
            d.textContent = ','; 
          } else { 
            d.className = 'digit-block'; 
            d.textContent = char; 
          }
          el.appendChild(d);
        });

        el.addEventListener('pointerdown', (e) => onPointerStart(e, tile.value, tile.id));
        workPane.appendChild(el);
      });
      
      updateTotal(sum);
    }

    function updateTotal(val) {
      currentTotal = parseFloat(val.toFixed(4));
      document.getElementById('sumText').textContent = new Intl.NumberFormat('en-US').format(currentTotal);
      
      // Auto-zoom number line to sensible level
      currentZoomIndex = getSensibleZoomIndex(currentTotal);
      updateNumberLine();
      
      if(challengeMode) checkWinCondition();
    }

    // ====== DRAG HANDLERS ======
    function onPointerStart(e, value, source) {
      e.preventDefault(); e.stopPropagation();
      if (e.currentTarget.setPointerCapture) try { e.currentTarget.setPointerCapture(e.pointerId); } catch(_) {}

      const targetRect = e.currentTarget.getBoundingClientRect();
      gesture = {
        startX: e.clientX, startY: e.clientY,
        moved: false, source, value
      };

      const onMove = (ev) => {
        if (!gesture) return;
        if (!gesture.moved && (Math.abs(ev.clientX - gesture.startX) > 5 || Math.abs(ev.clientY - gesture.startY) > 5)) {
          gesture.moved = true;
          beginDrag(gesture, targetRect);
        }
        if (gesture.moved) {
          if (!draggedTile) return;
          draggedTile.x = ev.clientX; draggedTile.y = ev.clientY;
          updateDragVisual();
        }
      };
      const onEnd = (ev) => { handleEnd(ev); cleanup(); };
      function cleanup() {
        document.removeEventListener('pointermove', onMove);
        document.removeEventListener('pointerup', onEnd);
        document.removeEventListener('pointercancel', onEnd);
        gesture = null;
      }
      document.addEventListener('pointermove', onMove, {passive: false});
      document.addEventListener('pointerup', onEnd, {passive: false});
      document.addEventListener('pointercancel', onEnd, {passive: false});
    }

    function beginDrag(g, targetRect) {
      const placeValue = getPlaceValueType(g.value);
      if (g.source === 'tray') {
        draggedTile = { value: g.value, placeValue, x: g.startX, y: g.startY, sourceType: 'tray' };
      } else {
        const paneTile = tiles.find(t => t.id === g.source);
        if (!paneTile) return;
        draggedTile = { ...paneTile, sourceType: 'pane' };
      }
      dragOffset = { x: g.startX - targetRect.left, y: g.startY - targetRect.top };
      updateDragVisual();
    }

    function updateDragVisual() {
      document.querySelectorAll('[data-dragging="true"]').forEach(el => el.remove());
      if (!draggedTile) return;

      const colorClass = getVisualClass(draggedTile.placeValue);
      const g = document.createElement('div');
      g.className = `tile ${colorClass} dragging`;
      g.dataset.dragging = 'true';

      const digits = getDigitsArray(draggedTile.value);
      digits.forEach(char => {
        const d = document.createElement('div');
        if (char === ',') { 
          d.className = 'digit-block comma-block'; 
          d.textContent = ','; 
        } else { 
          d.className = 'digit-block'; 
          d.textContent = char; 
        }
        g.appendChild(d);
      });

      const gx = draggedTile.x - dragOffset.x;
      const gy = draggedTile.y - dragOffset.y;
      g.style.transform = `translate3d(${gx}px, ${gy}px, 0) rotate(-3deg) scale(1.05)`;
      document.body.appendChild(g);
    }

    function handleEnd(e) {
      if (!draggedTile) return;
      const workPane = document.getElementById('workPane');
      const paneRect = workPane.getBoundingClientRect();

      if (e.clientY < paneRect.bottom && e.clientY > paneRect.top) {
        let dropX = e.clientX - paneRect.left - dragOffset.x;
        let dropY = e.clientY - paneRect.top - dragOffset.y;

        const snapLinePos = getSnapLinePosition(draggedTile.placeValue);
        const distanceToLine = Math.abs(dropY - snapLinePos.y);

        let finalX, finalY, parentId = null;
        const order = getPlaceValueOrder(draggedTile.placeValue);
        let zIndex = 1000 + order;

        if (distanceToLine < SNAP_LINE_DISTANCE) {
          finalX = snapLinePos.x;
          finalY = snapLinePos.y;
        } else {
          const overlay = findOverlayTarget(dropX, dropY, draggedTile.placeValue, 
            draggedTile.sourceType === 'pane' ? draggedTile.id : null);
          if (overlay) {
            finalX = overlay.snapX; finalY = overlay.snapY; parentId = overlay.tile.id;
          } else {
            finalX = dropX; finalY = dropY;
          }
        }

        if (draggedTile.sourceType === 'tray') {
          tiles.push({
            id: Date.now() + Math.random(),
            value: draggedTile.value,
            placeValue: draggedTile.placeValue,
            x: finalX, y: finalY, parentId, zIndex
          });
        } else {
          const existing = tiles.find(t => t.id === draggedTile.id);
          if (existing) {
            existing.x = finalX; existing.y = finalY; existing.parentId = parentId; existing.zIndex = zIndex;
          }
        }
      } else if (draggedTile.sourceType === 'pane') {
        tiles = tiles.filter(t => t.id !== draggedTile.id);
      }

      draggedTile = null;
      document.querySelectorAll('[data-dragging="true"]').forEach(el => el.remove());
      renderWorkPane();
    }

    // ====== RESOURCE TOOLS ======
    document.getElementById('speakBtn').addEventListener('click', () => {
      const text = currentTotal.toString();
      const utterance = new SpeechSynthesisUtterance(text);
      utterance.rate = 0.9;
      window.speechSynthesis.speak(utterance);
    });

    document.getElementById('challengeBtn').addEventListener('click', () => {
      challengeMode = !challengeMode;
      const banner = document.getElementById('challengeBanner');
      const btn = document.getElementById('challengeBtn');
      
      if(challengeMode) {
        banner.style.display = 'block';
        btn.style.background = '#f59e0b';
        generateNewTarget();
      } else {
        banner.style.display = 'none';
        btn.style.background = '';
      }
    });

    function generateNewTarget() {
      targetNumber = Math.floor(Math.random() * 9000) + 100;
      document.getElementById('targetNum').textContent = new Intl.NumberFormat().format(targetNumber);
    }

    function checkWinCondition() {
      if(currentTotal === targetNumber) {
        celebrate();
        setTimeout(generateNewTarget, 3000);
      }
    }

    function celebrate() {
      const colors = ['#ef4444', '#3b82f6', '#10b981', '#f59e0b'];
      for(let i=0; i<50; i++) {
        const c = document.createElement('div');
        c.className = 'confetti';
        c.style.left = Math.random() * 100 + 'vw';
        c.style.background = colors[Math.floor(Math.random() * colors.length)];
        c.style.animationDuration = (Math.random() * 2 + 2) + 's';
        document.body.appendChild(c);
        setTimeout(() => c.remove(), 4000);
      }
      const utterance = new SpeechSynthesisUtterance("Great Job!");
      window.speechSynthesis.speak(utterance);
    }

    document.getElementById('toggleChartBtn').addEventListener('click', () => {
      const chart = document.getElementById('multChart');
      chart.style.display = chart.style.display === 'block' ? 'none' : 'block';
    });

    document.querySelectorAll('.drawer-tab').forEach(tab => {
      tab.addEventListener('click', () => {
        activeDrawer = tab.dataset.drawer;
        document.querySelectorAll('.drawer-tab').forEach(t => {
          t.classList.toggle('active', t === tab);
          if(t === tab) t.scrollIntoView({behavior: 'smooth', inline: 'center'});
        });
        renderActiveDrawer();
      });
    });

    document.getElementById('resetBtn').addEventListener('click', () => {
      tiles = [];
      renderWorkPane();
    });

    // Start
    buildMultChart();
    renderActiveDrawer();
    renderWorkPane();
    updateNumberLine();

  </script>
</body>
</html>
